% structure +
% create index +
% create psi +
% bitmap +
% auxiliary data structures +
% ef +
% decode bv->psi +
% decode psi->sa +
% final structure +
% complexity +

Перейдем к описанию реализации CSA. Как было упомянуто в обзоре литературы, для начала необходимо
построить индекс таким же способом, как это происходит в suffix array. Для этого требуется $O(n)$ операций.

\textbf{Структура CSA}

\begin{lstlisting}[caption=CSA structure]
type Csa struct {
	text            string
	suffixOffsets   []int
	psi             []uint64
	length          int
}
\end{lstlisting}

На приведенном выше листинге 4 обозначена упрощенная структура CSA. Она состоит из исходного текста
(сжимается только индекс, текст остается в прежнем виде), индекса, $\psi$-массива и длины текста.
Индекс строится с помощью функции, в которой за основу алгоритма взят алгоритм построения suffix array
из библиотеки языка Go.

\textbf{Построение $\psi$-массива}

Для построения $\psi$-массива нужно принять $\psi[0] = \$$. Затем произвести итеративный обход
suffix array и найти индекс, соответствующее значение которого в suffix array совпадает с текущим,
увеличенным на единицу. В листинге 5 показан псевдокод алгоритма.

\begin{lstlisting}[caption=Построение CSA]
func ConstructPsi() {
	for i < len {
		if sa[j] = sa[i] + 1 {
			psi[i] = j
		}
	}
}
\end{lstlisting}

\textbf{Вспомогательные структуры данных}

Для хранения данных используется битмап (bitmap) из пакета\\ Roaring.bitmap. %https://github.com/RoaringBitmap/roaring
Это быстрая и эффективная реализация битмапа. Также Roaring используется во многих продуктах,
таких как Apache Druid, LinkedIn Pinot, Google Procella и т.д. % https://roaringbitmap.org/

Полученный $\psi$-массив представляет собой набор монотонно неубывающих последовательностей чисел.
Алгоритм Elias-Fano позволяет преобразовывать каждую такую последовательность в битвектор в отдельности.
Количество этих последовательностей совпадает с размером алфавита, используемого в тексте.
Возникает вопрос, каким образом можно организовать хранение таких битвекторов.

Одним из решений является использование двух дополнительных массивов:
первый для хранения оступа в $\psi$-массиве, второй для хранения символа,
соответствующего возрастающей последовательности.
В этой работе кодировка текста представляет собой ASCII-код или код меньшего размера.
Таким образом, размер алфавита ограничен 128 символами. Следовательно, размер
дополнительных массивов не превышает $2 \cdot m$, где $m$ -- размер алфавита.
Массив с оступами используется для быстрого индексирования по массиву битмапов.

Заполнение дополнительных структур данных и расчет отступов происходит при сжатии каждой отдельной
монотонной неубывающей последовательности индексов.
Для отделения таких последовательностей используется описанное ранее свойство из Леммы \ref{lemma:1}.
Нарушение возрастания $\psi$-массива соответсвует смене символа. Таким образом можно идексировать
битмапы и заполнить вспомогательный массив с символами используемого алфавита.

\textbf{Elias-Fano}

Сжатие при помощи алгоритма Elias-Fano осуществляется для каждой отдельной последовательности.
При этом происходит предварительное построение верхней и нижней частей (младших и старших биты)
битового представления чисел из этой последовательности. Рассчитывается отступ для дальнейшего
быстрого доступа к младшим битам. В процессе сжатия числа записываются в битмап,
в котором можно индексироваться за константное время.

Для того чтобы получить доступ к элементу последовательности (части $\psi$-массива),
необходимо использовать функцию $select(i)$, реализованную в битмапе, работающую за $O(1)$.
Для проверки корректности работы алгоритма реализована функция получения всего $\psi$-массива
при помощи вызова $select(i)$.

\textbf{Восстановление suffix array}

Для получения доступа к элементу suffix array $sa[i]$ нет необходимости полностью декодировать
$\psi$-массив. Для этого требуется осуществить проход по $\psi$-массиву, пока не будет достигнут
последний элемент. Сосчитав количество шагов до последнего элемента $h(i)$, найдем индекс искомого
значения путем несложного вычисления: $sa[i] = n - h(i)$. Такой алгоритм требует $O(n)$ операций.

\textbf{Окончательная структура CSA}

После добавления вспомогательных данных структура CSA принимает вид, показанный на листинге 6

\newpage
\begin{lstlisting}[caption=CSA structure]
type Csa struct {
	text      string
	bv        []*CompressedText
	seqOffset []int
	seqChar   []byte
	length    int
	alphLen   int
}
\end{lstlisting}

Важно подчеркнуть, что теперь нет необходимости хранить индексы и вспомогательный $\psi$-массив.
Вместо этого данные хранятся в сжатом виде в последовательности битвекторов.
Кроме того, исходный текст все так же остается в первоначальном виде.

Таким образом, для хранения сжатого индекса требуется $n \cdot \log |\sigma| + o(n)$,
где $|\sigma|$ -- размер алфавита. Суммарно для поиска элемента требуется $O(n\cdot \log n)$ операций.
