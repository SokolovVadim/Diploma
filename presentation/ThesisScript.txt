1. Цель и задачи +
2. Актуальность +
3. Общая идея. Кратко сказать об индексах по подстрокам вообще, но не больше, чем нужно, чтобы подвести к сжатым. +
4. Новизна
Использование таблицы для индексирования по битмапу +
5. Результаты +
6. Выводы +
Алгоритмы во внешней памяти


1. Цели и задачи
Данная работа посвящена исследованию структур данных, использующих сжатые индексы (succinct index) для хранения текстовой информации. Целью данной работы является сравнение текущих подходов для текстового поиска по подстрокам. Исследуется применимость сжатых индексов на практике при работе с данными определенного типа. Производится сравнение как с традиционными решениями (suffix array), так и с более современными (radix tree), использующими подход для индексирования, отличный от исследуемых структур данных


Задача: для этого предлагается протестировать структуры данных, позволяющие индексировать текст (Suffix array, Radix tree), и проверить эффективность поиска подстроки на текстовых данных разного содержания. Кроме того,  ставится задача реализовать на языке Go сжатый суффиксный массив, чтобы рассмотреть его преимущества перед традиционным суффиксным массивом.
2. Актуальность
Работа с текстовыми данными находит применение в широком спектре задач современной компьютерной индустрии.
Существует ряд проблем, связанных с поиском информации в поисковых сервисах.
При поиске по документам применяется индексирование. Традиционным методом является построение inverted index. Это структура данных, в которой для каждого слова коллекции документов в соответствующем списке перечислены все документы в коллекции, в которых оно встретилось. При обработке многословного запроса берётся пересечение списков, соответствующих каждому из слов запроса.


Например, в ряде задач биоинформатики присутствует поиск паттерна в ДНК-коде и коде белковой структуры, которые не представляют собой слова и соответственно inverted index для них не применим. Аналогично в некоторых восточных языках (китайский, японский) текст не делится на отдельные слова. Дополнительно, inverted index ограничен при поиске строки, похожей на искомую, но не совпадающую с ней в точности. Например, при поиске информации в поисковых системах, где в качестве запроса используется текст, содержащий орфографические ошибки или другие неточности, inverted index не сможет дать пользователю искомый ответ.


В этих случаях используются индексы, построенные на отсортированных суффиксах исходного текста. Примером такого индекса является суффиксный массив (suffix array).
В нем реализована возможность поиска подстроки, что позволяет решать задачи, недоступные для inverted index. В свою очередь, suffix array может занимать место, превосходящее исходный текст до 50 раз. Поэтому может оказаться выгоднее выполнять простое сканирование по тексту в RAM, чем иметь индекс, который в RAM не помещается, т.к. операции по чтению / записи информации во внешней памяти являются значительно более затратными.
В связи с этим существует необходимость исследования различных способов уменьшения потребляемой памяти без существенных затрат на поиск данных. 
Одним из возможных решений такого рода задач являются сжатые структуры данных (succinct data structures).


Пусть n - количество символов в тексте, σ - размер алфавита.
Тогда размер текста: T = nlogσ.
Размер суффиксного массива: I = nlogn + nlogσ.
Сжатый суффиксный массив:   I = n * (σ + logσ)




3. Общая идея: Compressed suffix array
Сжатые структуры используют близкое к теоретически минимальному количеству информации для хранения данных. К тому же существует возможность декодировать исходный текст из индекса (self-index). Предположим, что для хранения некоторого количества данных требуется Z бит. Сжатые структуры данных занимают 𝑍 + 𝑜(𝑍) бит. Например структура данных, занимающая 𝑍 + ln(𝑍) бит памяти, является сжатой.
Сжатые структуры данных очень эффективно кодируют данные в виде последовательности нулей и единиц, поэтому для использования их не нужно декодировать. Доступ к содержимому осуществляется путем считывания битов в различных позициях битового вектора при помощи операций rank и select.
rank(x) - возвращает количество битов, установленных в 1, до позиции x включительно
select(i) - возвращает позицию i-й 1. Это обратная функция к функции rank(x). Например, если select (8) = 10, то rank (10) = 8.
Сжатие осуществляется при помощи алгоритма Elias-Fano.


4. Новизна
В ходе разработки структуры данных сжатого суффиксного массива была задействована оптимизация по памяти, заключающаяся в добавлении индексации по битмапу, позволяющая использовать меньше памяти, чем аналоги, использующие вспомогательные структуры данных.
Решена задача по объединению bitmap для алфавита из большого количества символов (порядка 8 byte) --sequence quotienting. Для этого использована таблица с отступами на начало каждого битмапа, соответствующего определенному символу алфавита.


Indexation Optimization:
1 3 8 12 19 26 31 | 2 4 9 | 5 7 10 11 18 23 27
Bitmap offset table:
0, 7, 10
a, b, c


5. Результаты
Реализован алгоритм сжатия индекса в CSA, построен bitmap, реализованы функции доступа по индексу suffix array через rank() и select(), операция поиска подстроки.
Реализовано сравнение suffix array, radix tree, csa. Скорость построения структуры данных, требуемая память для хранения текста, скорость поиска подстроки для текстов различного содержания (Amazon Text Corpora, DNA, Proteins, English, Pitches).
6. Выводы
Рассмотренная структура данных, сжатый суффиксный массив (CSA), показала свою эффективность с точки зрения памяти, занимаемой для хранения индекса. Относительно традиционного suffix array при достаточно большом размере исходного текста CSA позволяет использовать меньше памяти, чем suffix array, сохраняя при этом возможность поиска подстроки. При малых значениях размера входного текста suffix array является более эффективным с точки зрения потребляемой памяти, что вызвано дополнительными затратами на обслуживание вспомогательных структур данных, использующихся для построения сжатого индекса. В то же время, как алгоритм построения индекса, так и поиска подстроки в CSA работают медленнее, чем в исходном.
Тем не менее, существуют методы улучшения скорости работы этих алгоритмов, позволяющие CSA достигнуть результатов, не уступающих suffix array.
Результаты, полученные при сравнении radix tree с остальными исследуемыми структурами данных, подтверждают эффективность поиска подстроки в radix tree за константное время. Однако для индексации по тексту необходимо заполнить дерево подстроками исходного текста, занимающими значительно большие объемы памяти по сравнению с suffix array и CSA. Аналогично, скорость заполнения дерева при построении не позволяет считать radix tree эффективным при работе с подстроками исходного текста.
7. Заключение
Дальнейшие исследования в этой области могут опираться на разработку сжатых представлений существующих классических структур данных. Применение методов сжатия, таких как рассмотренный в этой работе алгоритм Elias-Fano, может позволить производить сжатое представление данных различного типа, предварительно преобразованных к нужному формату. На основании экспериментов выявлены достоинства и недостатки исследуемых алгоритмов и структур данных для работы над реальными прикладными задачами. Сжатые структуры данных могут быть задействованы в работе алгоритмов, использующих хранение индекса во внешней памяти. Эта тема является малоизученной, поэтому сжатие индекса представляет особый интерес в области индексирования по подстрокам во внешней памяти.