1. Цель и задачи +
2. Актуальность +
3. Общая идея. Кратко сказать об индексах по подстрокам вообще, но не больше, чем нужно, чтобы подвести к сжатым. +
4. Новизна
Использование таблицы для индексирования по битмапу +
5. Результаты +
6. Выводы +
Алгоритмы во внешней памяти


Сложности создания / поиска:
SA +
Radix +
my CSA +
perfect CSA +


Elias-Fano
Test speed & speech 0 +
Test speed & speech 1 +
Test speed & speech 2


1. 2 Цели и задачи
Данная работа посвящена исследованию структур данных, использующих сжатые индексы (succinct index) для хранения текстовой информации. Целью данной работы является сравнение текущих подходов для текстового поиска по подстрокам. Исследуется применимость сжатых индексов на практике при работе с данными определенного типа. Производится сравнение как с традиционными решениями (suffix array), так и с более современными (radix tree), использующими подход для индексирования, отличный от исследуемых структур данных.


Задача: для этого предлагается протестировать структуры данных, позволяющие индексировать текст (Suffix array, Radix tree), и проверить эффективность поиска подстроки на текстовых данных разного содержания. Кроме того,  ставится задача реализовать на языке Go сжатый суффиксный массив, чтобы рассмотреть его преимущества перед традиционным суффиксным массивом.
2. 3 Актуальность
Работа с текстовыми данными находит применение в широком спектре задач современной компьютерной индустрии.
Существует ряд проблем, связанных с поиском информации в поисковых сервисах.
При поиске по документам применяется индексирование. Традиционным методом является построение inverted index. Это структура данных, в которой для каждого слова коллекции документов в соответствующем списке перечислены все документы в коллекции, в которых оно встретилось. При обработке многословного запроса берётся пересечение списков, соответствующих каждому из слов запроса. Inverted index занимает 5-10% от исходного текста и до 50% с учетом позиции слова в тексте. Важно отметить, что по такому индексу невозможно восстановить оригинальный текст.


4 На практике встречаются случаи, в которых невозможно использо-
вать традиционный поиск по слова. Например, в ряде задач биоинформатики присутствует поиск паттерна в ДНК-коде и коде белковой структуры, которые не представляют собой слова и соответственно inverted index для них не применим.
5 Аналогично в некоторых восточных языках (китайский, японский) текст не делится на отдельные слова.
6 Дополнительно, inverted index ограничен при поиске строки, похожей на искомую, но не совпадающую с ней в точности. Например, при поиске информации в поисковых системах, где в качестве запроса используется текст, содержащий орфографические ошибки или другие неточности, inverted index не сможет дать пользователю искомый ответ.


Suffix array: 7 В этих случаях используются индексы, построенные на отсортированных суффиксах исходного текста. Примером такого индекса является суффиксный массив (suffix array).
В нем реализована возможность поиска подстроки, что позволяет решать задачи, недоступные для inverted index.  Суффиксный массив занимает достаточно большой размер, тк. для хранения индекса требуется O(nlogn) памяти при хранении nlog|σ| бит текста.
Построение: O(n)
Поиск:            O(logn)
Память:         O(nlogn)


Radix tree: 8 Radix tree представляет собой сжатое prefix tree. В свою очередь, prefix tree является структурой данных, которая предоставляет интерфейс ассоциативного массива и позволяет хранить значения в виде key-value пар. В этом исследовании в качестве key выбраны строки, причем в отличие от обычный деревьев, на ребрах radix tree могут храниться как один элемент (символ), так и последовательность элементов (строка). Radix tree широко применяется в ядре Linux для связи указателя с длинным целочисленным ключом. Эта структура данных эффективна с точки зрения скорости поиска и хранения информации. В тоже время, Radix tree применяется в IP-адресации,
так как очень удобно для хранения иерархической структуры IP-адресов. Рассмотрим подробнее характеристики radix tree. Пусть требуется
хранить ключи размером k при хранении n элементов в дереве. Тогда
добавление элемента, поиск и удаление элемента занимают O(k) операций.
Построение: O(n)
Поиск:            O(k)
Память:         O(n^2)


CSA: 9 Suffix array может занимать место, превосходящее исходный текст до 50 раз. Поэтому может оказаться выгоднее выполнять простое сканирование по тексту в RAM, чем иметь индекс, который в RAM не помещается, т.к. операции по чтению / записи информации во внешней памяти являются значительно более затратными.
В связи с этим существует необходимость исследования различных способов уменьшения потребляемой памяти без существенных затрат на поиск данных. 
Одним из возможных решений такого рода задач являются сжатые структуры данных (succinct data structures).


Пусть n - количество символов в тексте, σ - размер алфавита.
Тогда размер текста: T = nlogσ.
Размер суффиксного массива: I = nlogn + nlog|σ|.
Сжатый суффиксный массив:   I = n * (2*8 + log|σ|) + 8*|σ| + 32*|σ|
                                                             psi     + text      + alph  + offset
Построение:     O(n logn) SA, PSI, bitmaps
Поиск:               O((logn)^2) search SA and find sa from psi
Perfect search: O(logn), perfect size: O(n) + o(n)
Roaring: Given N integers in [0,x), then the serialized size in bytes of a Roaring bitmap should never exceed this bound: 8 + 9 * ((long)x+65535)/65536 + 2 * N
-> max 2byte per int.
Elias-Fano: Этот способ делает возможным хранение
неубывающей последовательности n целых чисел размером [0, m) , занимая
2n + n[log m/n] бит, предоставляя доступ к i -му элементу за O(1).


3. Общая идея: Compressed suffix array
10 Сжатые структуры используют близкое к теоретически минимальному количеству информации для хранения данных. К тому же существует возможность декодировать исходный текст из индекса (self-index). Предположим, что для хранения некоторого количества данных требуется Z бит. Сжатые структуры данных занимают 𝑍 + 𝑜(𝑍) бит. Например структура данных, занимающая 𝑍 + ln(𝑍) бит памяти, является сжатой.
Сжатые структуры данных очень эффективно кодируют данные в виде последовательности нулей и единиц, поэтому для использования их не нужно декодировать. Доступ к содержимому осуществляется путем считывания битов в различных позициях битового вектора при помощи операций rank и select.
rank(x) - возвращает количество битов, установленных в 1, до позиции x включительно
select(i) - возвращает позицию i-й 1. Это обратная функция к функции rank(x). Например, если select (8) = 10, то rank (10) = 8.
11. Сжатие осуществляется при помощи алгоритма Elias-Fano. Сжимается вспомогательный Psi-массив -- массив из successor-ов, самых больших суффиксов подстроки. Индекс имеет битовое представление и записывается в битмап. Дополнительно используется таблица с отступами для разных последовательностей Psi-массива, хранящихся в битмапе.


4. Новизна
12 В ходе разработки структуры данных сжатого суффиксного массива была задействована оптимизация по памяти, заключающаяся в добавлении индексации по битмапу, позволяющая использовать меньше памяти, чем аналоги, использующие вспомогательные структуры данных.
Решена задача по объединению bitmap для алфавита из большого количества символов (порядка 8 byte) --sequence quotienting. Для этого использована таблица с отступами на начало каждого битмапа, соответствующего определенному символу алфавита.


Indexation Optimization:
1 3 8 12 19 26 31 | 2 4 9 | 5 7 10 11 18 23 27
Bitmap offset table:
0, 7, 10
a, b, c


5. Результаты
13 Реализован алгоритм сжатия индекса в CSA, построен bitmap, реализованы функции доступа по индексу suffix array через rank() и select(), операция поиска подстроки.
Реализовано сравнение suffix array, radix tree, csa.
Исследованы скорость построения структуры данных, требуемая память для хранения текста, скорость поиска подстроки для текстов различного содержания (Amazon Text Corpora, DNA, Proteins, English, Pitches - звуковой ряд).
14 На слайде можно видеть время построения индекса для сжатого суффиксного массива в зависимости от размера документа.
15 Здесь представлена сравнительная характеристика времени поиска подстроки в тексте в зависимости от размера документа.
16 Поиск подстроки в CSA для текстов разного содержания.
17 Сжатие CSA по сравнению с SA в зависимости от размера текста. При малых значениях размера входного текста suffix array потребляет меньше памяти, т.к. не имеет издержек на обслуживание вспомогательных структур данных.
18 Сжатие CSA для разных текстовых данных, имеющих разный размер алфавита.


6. Выводы
19 Рассмотренная структура данных, сжатый суффиксный массив (CSA), показала свою эффективность с точки зрения памяти, занимаемой для хранения индекса. Относительно традиционного suffix array при достаточно большом размере исходного текста CSA позволяет использовать меньше памяти, чем suffix array, сохраняя при этом возможность поиска подстроки. При малых значениях размера входного текста suffix array является более эффективным с точки зрения потребляемой памяти, что вызвано дополнительными затратами на обслуживание вспомогательных структур данных, использующихся для построения сжатого индекса. В то же время, как алгоритм построения индекса, так и поиска подстроки в CSA работают медленнее, чем в исходном.
Тем не менее, существуют методы улучшения скорости работы этих алгоритмов, позволяющие CSA достигнуть результатов, не уступающих suffix array.
Результаты, полученные при сравнении radix tree с остальными исследуемыми структурами данных, подтверждают эффективность поиска подстроки в radix tree за константное время. Однако для индексации по тексту необходимо заполнить дерево подстроками исходного текста, занимающими значительно большие объемы памяти по сравнению с suffix array и CSA, что не позволяет считать radix tree эффективным при работе с подстроками исходного текста.
7. Заключение
20 Дальнейшие исследования в этой области могут опираться на разработку сжатых представлений существующих классических структур данных. Применение методов сжатия, таких как рассмотренный в этой работе алгоритм Elias-Fano, может позволить производить сжатое представление данных различного типа, предварительно преобразованных к нужному формату. На основании экспериментов выявлены достоинства и недостатки исследуемых алгоритмов и структур данных для работы над реальными прикладными задачами. Сжатые структуры данных могут быть задействованы в работе алгоритмов, использующих хранение индекса во внешней памяти. Эта тема является малоизученной, поэтому сжатие индекса представляет особый интерес в области индексирования по подстрокам во внешней памяти.
21. Спасибо за внимание.